<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<title>My first Three.js app</title>
</head>

<style>
	body { margin: 0; }
	canvas { width: 100%; height: 100% }
	html {
		background: #2b2b2b;
	}
	body {
		text-align: center;
		color: #ffffff;
	}
	.count {
		position: relative;
		margin: 40px 0;
		padding: 14px 16px;
		font-size: 40px;
		line-height: 40px;
		font-weight: 600;
		font-smoothing: antialiased;
		-webkit-font-smoothing: antialiased;
		-moz-border-radius: 4px;
		-webkit-border-radius: 4px;
		border-radius: 4px;
		display: inline-block;
		background: rgba(255, 255, 255, 0.1);
	}
	.count.glow {
		text-shadow: 0 0 4px #ffffff;
	}
</style>

<body>
<div id="world">
	<div class="count">0</div>
</div>

</body>


<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
<script src="js\three.js\build\three.js"></script>
<script>
	var ballTexture = new THREE.TextureLoader().load("/images/pokeball1.jpg");
	var scene = new THREE.Scene();
	var mousePosX = 0;
	var mousePosY = 0;
	var particles = [];
	var counter = 0;
	var counterP = 0;
	shadowLight = new THREE.DirectionalLight(0xffffff, .8);
	shadowLight.position.set(1, 1, 1);
	scene.add(shadowLight);
	var clock = new THREE.Clock();
	var difficulty = 0;
	var lose = 0;
	function cube_construct(o, x, y, z, w, h, d, c){
		x=x*5;
		y=y*5;
		z=z*5;
		w=w*5;
		h=h*5;
		d=d*50;
		var material = new THREE.MeshLambertMaterial(
				{
					color: c
				} );
		var geometry = new THREE.CubeGeometry(w, h, d, 1, 1, 1);
		var mesh = new THREE.Mesh( geometry, material );
		mesh.position.x=x-(w/2);
		mesh.position.y=y;
		mesh.position.z=z;
		o.add( mesh );
	}
	function dogGenerator() {
		var xxx = new THREE.Object3D();
		//face
		cube_construct(xxx,-5,0,0,10,10,1,"rgb(234,177,62)");
		cube_construct(xxx,-5.5,-2.5,0,7,5,1,"rgb(223,216,174)");
		//mouth
		cube_construct(xxx,-6,-1,.5,2,1.5,1,"rgb(0,0,0)");
		cube_construct(xxx,-6.5,-2,.5,1,0.5,1,"rgb(0,0,0)");
		cube_construct(xxx,-6.5,-2.5,.5,4,0.5,1,"rgb(0,0,0)");
		cube_construct(xxx,-10.5,-2,.5,0.5,0.5,1,"rgb(0,0,0)");
		//sunglass
		cube_construct(xxx,-6,2.5,.5,9,0.5,1,"rgb(0,0,0)");
		cube_construct(xxx,-6,1.6,.5,2.5,1.6,1,"rgb(0,0,0)");
		cube_construct(xxx,-10,1.5,.5,3,2,1,"rgb(0,0,0)");
		//ears
		cube_construct(xxx,-12,5,0,3,1.5,1,"rgb(255, 223, 174)")
		cube_construct(xxx,-12.5,6,0,2,1,1,"rgb(255, 223, 174)")
		cube_construct(xxx,-13,6.6,0,1,0.5,1,"rgb(255, 223, 174)")
		cube_construct(xxx,-13.25,7,0,0.5,0.25,1,"rgb(255, 223, 174)")
		cube_construct(xxx,-5,5,0,3,1.5,1,"rgb(255, 223, 174)")
		cube_construct(xxx,-5.5,6,0,2,1,1,"rgb(255, 223, 174)")
		cube_construct(xxx,-6,6.6,0,1,0.5,1,"rgb(255, 223, 174)")
		cube_construct(xxx,-6.25,7,0,0.5,0.25,1,"rgb(255, 223, 174)")
		xxx.position.x=-700;
		return xxx;
	}
	function initial() {
		console.log("1");
		for (var i = 0; i < particles.length; i++) {
			scene.remove(particles[i]);
		}
		particles = [];
		clock = new THREE.Clock();
		difficulty = 0;
	}
	function createParticle() {
		var randomL = Math.random();
		var randomW = Math.random();
		// var randomT = Math.random();
		// var geometry = new THREE.BoxGeometry(randomL*20+20, randomW*20 + 20, randomT * 20 + 20);
		// var color = new THREE.Color( getRandomColor() );
		// var material = new THREE.MeshPhongMaterial({shading: THREE.FlatShading});
		// material.color = color;
		// var cube = new THREE.Mesh(geometry, material);
		// return cube;
		var geometry = new THREE.SphereBufferGeometry(20, 32, 32);
		var material = new THREE.MeshPhongMaterial({ map: ballTexture});
		var sphere = new THREE.Mesh(geometry, material);
		sphere.position.x = 3000;
		sphere.position.y = -1000+ randomL * 2000;
		return sphere;
	}
	function detectCollision(doge, ball) {
		if ((Math.abs(doge.position.x - ball.position.x) < 35) && (Math.abs(doge.position.y - ball.position.y) < 35)) {
			console.log("Lose");
			return 1;
		}
		else {
			return 0;
		}
	}
	function main() {
		var song = document.createElement('audio');
		song.setAttribute('src', 'Ridin.mp3');
		song.setAttribute('loop', 'true');

		song.play();

		var texture = new THREE.TextureLoader().load("/images/cat.jpg");
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		light = new THREE.HemisphereLight(0xffffff, 0xffffff, .3)

		// var camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 0.1, 1000);
		var camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 2000 );
		var renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		container = document.getElementById('world');
		container.appendChild(renderer.domElement);
		var cube = dogGenerator();
		cube.position.z = 0;
		scene.background = texture;
		scene.position.z = 100;
		scene.add(cube);
		scene.add(light);
		camera.position.z = 1000;
		var speedX = 0;
		var speedY = 0;
		window.addEventListener("mousemove", handleMouseMove) ;
		function handleMouseMove(event) {
			mousePosX = event.clientX;
			mousePosY = event.clientY;
		}
		var render = function() {
			if (difficulty < 18) {
				difficulty = Math.floor(clock.getElapsedTime()/1);
			}
			if (counter % (20-difficulty) == 0) {
				particles.push(createParticle());
				for (var i = 0; i < particles.length; i++) {
					scene.add(particles[i]);
				}
				counterP++;
			}
			requestAnimationFrame( render );
			cube.position.x = (mousePosX - 1/2 * window.innerWidth);
			cube.position.y=-(mousePosY - 1/2 * window.innerHeight);
			renderer.render(scene, camera);
			for (var i = 0; i < particles.length; i++) {
				lose = detectCollision(cube, particles[i]);
				if (lose == 1) {
					lose = 0;
					initial();
					break;
				}
				particles[i].position.x -= 10+difficulty;
				particles[i].rotation.x += 0.05;
				particles[i].rotation.y += 0.05;
				particles[i].rotation.z += 0.05;
				if (particles[i].position.x <= -3000) {
					scene.remove(particles[i]);
					particles.shift();
				}
			}
			console.log(particles.length);
			counter++;
			console.log(lose);
		};
		countUp(9999);
		render();
	}
	function countUp(count)
	{
		var div_by = 1000,
				speed = Math.round(count / div_by),
				$display = $('.count'),
				run_count = 1,
				int_speed = 24;

		var int = setInterval(function() {
			if(run_count < div_by){
				$display.text(speed * run_count);
				run_count++;
			} else if(parseInt($display.text()) < count) {
				var curr_count = parseInt($display.text()) + 1;
				$display.text(curr_count);
			} else {
				clearInterval(int);
			}
		}, int_speed);
	}
	function game_over(){
		
	}
	main();
</script>
</html>